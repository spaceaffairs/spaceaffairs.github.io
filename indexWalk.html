<!DOCTYPE html>
<html>
  <script src="header.js"></script>

  <body>
    <main>
        <script src="menu.js"></script>
    </main>
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
	<script type="importmap">
			{
				"imports": {
					"three": "https://cdn.jsdelivr.net/npm/three@0.138.0/build/three.module.js"
				}
			}
	</script>
    <!-- <canvas id="c"></canvas> -->
    <div class="iasaLogo">
        <img class="iasa" src="images/IASA_logo_grau.svg">
    </div>
	<script type="module">

		import * as THREE from 'https://unpkg.com/three/build/three.module.js'
		import { OrbitControls } from 'https://unpkg.com/three/examples/jsm/controls/OrbitControls.js';


        let renderer, scene, camera;

        let line;

        const GRID_WIDTH = 200;
        const GRID_LENGTH = 200;
        const UNIT = 0.1;
        const MAX_POINTS = 10000;
        const walk = new Float32Array( MAX_POINTS * 2 ); // 3 vertices per point
        let index = 0;
        //const canvas = document.querySelector('#c');

        let t = 0;

        init();
        animate();

        function init() {
            // info
            const info = document.createElement( 'div' );
            info.style.position = 'absolute';
            info.style.top = '30px';
            info.style.width = '100%';
            info.style.textAlign = 'center';
            info.style.color = '#fff';
            info.style.fontWeight = 'bold';
            info.style.backgroundColor = 'transparent';
            info.style.zIndex = '1';
            info.style.fontFamily = 'Monospace';
            //info.innerHTML = "three.js plotting 3D functions";
            document.body.appendChild( info );
            // renderer
            renderer = new THREE.WebGLRenderer(  { alpha: true } );
            //renderer = new THREE.WebGLRenderer({
            //    canvas, 
            //    alpha: true,
            //});
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            document.body.appendChild( renderer.domElement );
            // scene
            scene = new THREE.Scene();
            // camera
            camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 10000 );
            camera.position.set( -235.27081612572493, -305.1106389014066, 717.6179850024755 );
            camera.up.set( -1,0,1);
            camera.rotation.set(0.4020158105765042, -0.29302629720505974, 1.0559101215524487);
            const controls = new OrbitControls(camera, renderer.domElement)
            controls.enableDamping = true;
            walk[0] = 0;
            walk[1] = 0;
            for ( let i = 2; i < MAX_POINTS * 2; i+=2 ) {
                walk[i] = walk[i-2] + (Math.random() * 2 - 1) * 0.02;
                walk[i+1] = walk[i-1] + (Math.random() * 2 - 1) * 0.02;
            }
            // geometry
            const geometry = new THREE.BufferGeometry();
            // attributes
            const positions = new Float32Array( MAX_POINTS * 3 ); // 3 vertices per point
            geometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
            // material
            const material = new THREE.PointsMaterial( { color: 0xf1c97d } );
            // line
            line = new THREE.Points( geometry,  material );
            scene.add( line );
            // update positions
            updatePositions();
        }

        // update positions
        function updatePositions() {
	        const positions = line.geometry.attributes.position.array;
	        let index = 0;
	        for ( let u = 0; u < MAX_POINTS * 2; u += 2 ) {
	                const cosu = Math.cos(walk[u]);
	                const cosv = Math.cos(walk[u+1]);
	                const sinu = Math.sin(walk[u]);
			        positions[ index ++ ] = -100 + (-18) * cosu * (3.0 * cosv - 30.0 * sinu + 90.0 *Math.pow(Math.abs(cosu),4) * sinu - 60.0 * Math.pow(Math.abs(cosu),6) * sinu + 5.0 * cosu * cosv * sinu );
			        positions[ index ++ ] = -200 + (-10.2) * sinu * (3.0 * cosv - 3.0 * Math.pow(Math.abs(cosu),2) * cosv - 48.0 * Math.pow(Math.abs(cosu), 4)*cosv + 48.0 * Math.pow(Math.abs(cosu),6) * cosv - 60.0 * sinu + 5.0 * cosu * cosv * sinu - 5.0 * Math.sign(cosu)*Math.pow(Math.abs(cosu), 3) * cosv * sinu - 80.0 * Math.sign(cosu)*Math.pow(Math.abs(cosu), 5) * cosv * sinu + 80.0 * Math.sign(cosu)*Math.pow(Math.abs(cosu), 7) * cosv * sinu) - 1.0;
			        positions[ index ++ ] = 18 * ( 3.0 + 5.0 * cosu * sinu) * Math.sin(walk[u+1]);
	        }
        }

        // render
        function render() {
            renderer.render( scene, camera );
        }

        // animate
        function animate() {
            if (index == 0) { 
                walk[index] = walk[MAX_POINTS * 2 - 2] + (Math.random() * 2 - 1) * 0.02;
                walk[index+1] = walk[MAX_POINTS * 2 - 1] + (Math.random() * 2 - 1) * 0.02;
            } else { 
                walk[index] = walk[index - 2] + (Math.random() * 2 - 1) * 0.02;
                walk[index+1] = walk[index - 1] + (Math.random() * 2 - 1) * 0.02;
            }
            index = (index + 2) % (MAX_POINTS * 2);
	        requestAnimationFrame( animate );
	        t = t + 0.001;
	        updatePositions();
	        line.geometry.attributes.position.needsUpdate = true; // required after the first render
	        render();
            //console.log(camera.position, camera.rotation);
        }
	</script>
  </body>
</html>
