<!DOCTYPE html>
<html>
  <script src="header.js"></script>

  <body>
    <main>
        <script src="menu.js"></script>
    </main>
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
	<script type="importmap">
			{
				"imports": {
					"three": "https://cdn.jsdelivr.net/npm/three@0.138.0/build/three.module.js"
				}
			}
	</script>
    <!-- <canvas id="c"></canvas> -->
    <div class="iasaLogo">
        <img class="iasa" src="images/IASA_logo_grau.svg">
    </div>
	<script type="module">

		import * as THREE from 'https://unpkg.com/three/build/three.module.js'
		import { OrbitControls } from 'https://unpkg.com/three/examples/jsm/controls/OrbitControls.js';


        let renderer, scene, camera;

        let line;

        const GRID_WIDTH = 200;
        const GRID_LENGTH = 200;
        const UNIT = 0.1;
        const MAX_POINTS = GRID_WIDTH*GRID_LENGTH*3;

        //const canvas = document.querySelector('#c');

        let t = 0;

        init();
        animate();

        function init() {
            // info
            const info = document.createElement( 'div' );
            info.style.position = 'absolute';
            info.style.top = '30px';
            info.style.width = '100%';
            info.style.textAlign = 'center';
            info.style.color = '#fff';
            info.style.fontWeight = 'bold';
            info.style.backgroundColor = 'transparent';
            info.style.zIndex = '1';
            info.style.fontFamily = 'Monospace';
            //info.innerHTML = "three.js plotting 3D functions";
            document.body.appendChild( info );
            // renderer
            renderer = new THREE.WebGLRenderer(  { alpha: true } );
            //renderer = new THREE.WebGLRenderer({
            //    canvas, 
            //    alpha: true,
            //});
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            document.body.appendChild( renderer.domElement );
            // scene
            scene = new THREE.Scene();
            // camera
            camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 10000 );
            camera.position.set( -400,100,500 );
            camera.up.set( 1,-3, -0.5);
            const controls = new OrbitControls(camera, renderer.domElement)
            controls.enableDamping = true
            // geometry
            const geometry = new THREE.BufferGeometry();
            // attributes
            const positions = new Float32Array( MAX_POINTS * 3 ); // 3 vertices per point
            geometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
            // material
            const material = new THREE.PointsMaterial( { color: 0xffffff } );
            // line
            line = new THREE.Points( geometry,  material );
            scene.add( line );
            // update positions
            updatePositions();
        }

        // update positions
        function updatePositions() {
	        const positions = line.geometry.attributes.position.array;
	        let index = 0;
	        for ( let uu = 0; uu < Math.PI; uu += 0.05 ) {
		        for ( let v = 0; v < 2 * Math.PI; v += 0.1 ) {
                    let u = uu + t;
	                const cosu = Math.cos(u);
	                const cosv = Math.cos(v);
	                const sinu = Math.sin(u);
			        positions[ index ++ ] = 200 + (-18) * cosu * (3.0 * cosv - 30.0 * sinu + 90.0 *Math.pow(Math.abs(cosu),4) * sinu - 60.0 * Math.pow(Math.abs(cosu),6) * sinu + 5.0 * cosu * cosv * sinu );
			        positions[ index ++ ] = -420 + (-10.2) * sinu * (3.0 * cosv - 3.0 * Math.pow(Math.abs(cosu),2) * cosv - 48.0 * Math.pow(Math.abs(cosu), 4)*cosv + 48.0 * Math.pow(Math.abs(cosu),6) * cosv - 60.0 * sinu + 5.0 * cosu * cosv * sinu - 5.0 * Math.sign(cosu)*Math.pow(Math.abs(cosu), 3) * cosv * sinu - 80.0 * Math.sign(cosu)*Math.pow(Math.abs(cosu), 5) * cosv * sinu + 80.0 * Math.sign(cosu)*Math.pow(Math.abs(cosu), 7) * cosv * sinu) - 1.0;
			        positions[ index ++ ] = (18) * ( 3.0 + 5.0 * cosu * sinu) * Math.sin(v);
		        }
	        }
        }

        // render
        function render() {
            renderer.render( scene, camera );
        }

        // animate
        function animate() {
	        requestAnimationFrame( animate );
	        t = t + 0.001;
	        updatePositions();
	        line.geometry.attributes.position.needsUpdate = true; // required after the first render
	        render();
        }
	</script>
  </body>
</html>
